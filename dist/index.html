<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<script>
			function toneOff() {
				document.getElementById("toneframe").contentWindow.location.reload();
			}
			function wagsOff() {
				document.getElementById("wagsframe").contentWindow.location.reload();
			}
		</script>
		<title>wags.fm</title>
	</head>
	<body>
		<audio
			id="wagsSilenceHack"
			loop
			src="https://media.graphcms.com/b0IXeyJzSDCZgVRHkFHL"
		>
			Your browser does not support the <code>audio</code> element.
		</audio>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>An SDOM Approach to Web Audio</h2>
					<p>Mike Solomon @ joyride.fm</p>
					<a href="https://mikesol-wac2022.surge.sh/"
						>mikesol-wac2022.surge.sh</a
					>
				</section>
				<section>
					<section><h1>A bit about me</h1></section>
					<section>
						<ul>
							<li>
								2011-2017: Work at IRCAM & Grame on various digital audio roles.
							</li>
							<li>
								Started my own company in 2017 to work on ML-based DSP
								algorithms, wound up
								<s
									>being bought out at a rock bottom price as the ship was
									sinking</s
								>
								exiting to a reputable group of seasoned professionals.
							</li>
							<li>
								On the heels of that <s>failure</s> resounding success, started
								a company with the same founders backed by the same
								<s>crazy</s> investors.
							</li>
						</ul>
					</section>
					<section>
						<h3>Where I landed</h3>
						<ul>
							<li>We're building a demo social rhythm game at joyride.fm</li>
							<li>
								We've open-sourced our stack, which includes:
								<ul>
									<li>
										<code>hyrule</code>: A functional reactive programming
										library.
									</li>
									<li>
										<code>deku</code>: Yet another Web UI library, because there
										aren't enough.
									</li>
									<li>
										<code>rito</code>: A set of three.js bindings for game
										development.
									</li>
									<li><code>ocarina</code>: A web audio library.</li>
								</ul>
							</li>
						</ul>
					</section>
					<section>
						<img src="./images/link.webp" />
					</section>
					<section>
						<h3>Alternative titles</h3>
						<ul>
							<li>
								<code>hyrule</code>: Hermetic Yonedas over Reactive Univalent
								Lazy Enclosures.
							</li>
							<li>
								<code>deku</code>: DOMs Emitted as Kan-extended Universals
							</li>
							<li><code>rito</code>: Reentrant Idempotent Temporal Oculars</li>
							<li>
								<code>ocarina</code>: Obvious Canned Acronym for Real-Time
								Isomporphic Non-linear Audio
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section><h1>Why, What and How</h1></section>
					<section>
						<h2>Why?</h2>
						<p>We're building social rhythm games in the browser.</p>
						<iframe width="900" height="500" src="https://joyride.fm"></iframe>
					</section>
					<section>
						<h2>Rhythm games</h2>
						<ul>
							<li>Reactive</li>
							<li>Tight rendering loop (60 FPS)</li>
							<li>Dynamic signal processing chains</li>
						</ul>
					</section>
					<section>
						<h2>What</h2>
						<p>
							An SDOM approach to web audio. SDOM is short for
							<b>Static DOM</b>, in contrast to the more popular <b>VDOM</b>, or
							virtual DOM.
						</p>
					</section>
					<section>
						<h2>How</h2>
						<p>
							PureScript Ocarina, a SDOM-inspired web audio library.
							<a href="https://github.com/mikesol/purescript-ocarina"
								>github.com/mikesol/purescript-ocarina</a
							>
						</p>
					</section>
					<section>
						<ul>
							<li>
								<b>Why</b>: To create reactive, immersive and impeccably timed
								web-based rhythm games.
							</li>
							<li><b>What</b>: The SDOM approach.</li>
							<li>
								<b>How</b>: PureScript Ocarina: horizontal and vertical events.
							</li>
						</ul>
					</section>
					<section>
						<h3>By the end, I hope you'll...</h3>
						<ul>
							<li class="fragment">
								...understand what the SDOM approach is, what forces led to it,
								its major design choices and its limitations.
							</li>
							<li class="fragment">
								...know when to reach for these patterns and how to use them.
							</li>
							<li class="fragment">
								...take away a bit of the theory behind SDOM.
							</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h1>Goal 1</h1>
						<h3>What is SDOM?</h3>
					</section>
					<section>
						<h3>Before SDOM, there was VDOM</h3>
						<ul>
							<li class="fragment">
								<b>Virtual DOM</b> Introduced by Angular and React.
							</li>
							<li class="fragment">
								An app is a function from a data model to a DOM.
							</li>
							<li class="fragment">
								When a data model changes, we diff the new VDOM against the old
								VDOM and apply the patch to the real DOM.
							</li>
						</ul>
					</section>
					<section>
						<h3>
							<span style="font-style: italic"
								>You Might Not Need The Virtual DOM</span
							>
							by Phil Freeman
						</h3>
						<blockquote>
							<small
								>Denotationally speaking, the virtual DOM is very appealing, but
								operationally, it is a heavyweight solution for many problems.
								Every time we modify our application state and rerun our render
								function, we allocate a new tree of (virtual) DOM components,
								and perform a tree diff in order to discover what must change in
								the actual DOM. For many (most?) applications, this seems to be
								overkill. We can optimize the diff algorithm in various ways,
								but ultimately, the diffing is essentially unnecessary - for
								simple changes to the model, I know precisely which nodes need
								to be updated. We simply need a way to make this obvious in the
								code.</small
							>
						</blockquote>
					</section>
					<section>
						<h3>SDOM: Design principles</h3>
						<ul>
							<li class="fragment" data-fragment-index="1">
								The nodes in a graph never change.*
							</li>
							<li class="fragment">
								Nodes listen event streams that modulate their properties.
							</li>
							<li class="fragment">
								Because the nodes are static, event streams can cache a
								reference to a node fire-and-forget to that reference.
							</li>
						</ul>
						<small class="fragment" data-fragment-index="1"
							>* Except for when they do.</small
						>
					</section>
					<section>
						<h3>Hello SDOM!</h3>
						<div class="ms-container">
							<div class="ms-col">
								<div id="hello-sdom"></div>
							</div>
							<div class="ms-col">
								<pre><code data-trim data-noescape>
type UIEvents = V
  ( buttonClicked :: Unit
  , sliderMoved :: Number
  )

hello e = runInElement' e
  ( envy $ vbus (Proxy :: _ UIEvents) \push event -> do
      D.div_
        [ D.button
            (click_ (bang push.buttonClicked))
            [text_ "Click Me" ]
        , D.div_
            [ text
                ( bang "Val: 0" <|>
                    ( append "Val: " <<< show
                        <$> fold
                          (const (add 1))
                          (bang unit <|> event.buttonClicked)
                          (-1)
                    )
                )
            ]
        , D.div_
            [ D.input
                (slider (bang push.sliderMoved))
                []
            , D.div_
                [ text
                    ( bang "Val: 50" <|>
                        ( append "Val: " <<< show
                            <$> event.sliderMoved
                        )
                    )
                ]
            ]
        ]
  )
  </code></pre>
							</div>
						</div>
					</section>
					<section>
						<h3>Hello SDOM-Audio!</h3>
						<div class="ms-container">
							<div class="ms-col" style="width: 300px">
								<div style="width: 300px" id="hello-sdom-audio"></div>
							</div>
							<div class="ms-col">
								<pre><code data-trim data-noescape>
dgl d de g ge h he i =
  delay d de [ gain g ge [ lowpass h he i ] ]

dgh d de g ge h he i =
  delay d de [ gain g ge [ highpass h he i ] ]

dgb d de g ge h he i =
  delay d de [ gain g ge [ bandpass h he i ] ]

fix \g0 -> gain_ 1.0
	[ b
	, delay { maxDelayTime: 2.5, delayTime: 1.0 } ((P.delayTime <<< ttap <<< second (calcSlope 0.0 0.5 100.0 2.45)) <$> sliderE)
			[ gain 0.4 ((P.gain <<< ttap <<< second (calcSlope 0.0 0.6 100.0 0.9)) <$> sliderE) [ b ] ]
	, dgh 0.15 empty 0.7 empty 1500.0 (fenv 1500.0 3000.0)
			[ fix
					\g1 -> gain 1.0 fade1
						[ dgh 0.4 empty 0.5 empty 3000.0 (fenv 3000.0 100.0)
								[ g0, g1 ]
						]
			]
	, dgh 0.29 ((P.delayTime <<< ttap <<< second (calcSlope 0.0 0.1 100.0 0.4)) <$> sliderE) {-(denv 0.29 0.9)-}  0.85 empty 2000.0
			(fenv 2000.0 5000.0)
			[ fix
					\g1 -> gain_ 1.0
						[ dgh 0.6 ((P.delayTime <<< ttap <<< second (calcSlope 0.0 0.8 100.0 0.3)) <$> sliderE) {-(denv 0.6 0.2)-}  0.6 empty 3500.0
								(fenv 3500.0 100.0)
								[ g0
								, ( fix
											\g2 -> gain 1.0 fade0
												[ dgb 0.75 ((P.delayTime <<< ttap <<< second (calcSlope 0.0 0.9 100.0 0.1)) <$> sliderE) {-(denv 0.75 0.99)-}  0.6
														empty
														4000.0
														(fenv 4000.0 200.0)
														[ g1, g2 ]
												, dgb 0.75 (denv 0.75 0.2) 0.55 empty 200.0 (fenv 200.0 4000.0) [ b ]
												]
									)
								]
						]
			]
	]
  </code></pre>
							</div>
						</div>
					</section>

					<!--

-->
					<section>
						<h3>SDOM-esque-audio: Benchmark</h3>
						<div class="ms-container">
							<div class="ms-col" style="width: 300px">
								<iframe id="wagsframe" src="wags.html"></iframe>
								<button onclick="wagsOff()">Refresh</button>
							</div>
							<div class="ms-col">
								<pre><code data-trim data-noescape>
music time= do
  let
		e0 = adsr<<<add 0.03
		oon = bangOn'
		oof = bangOff' <<< add 0.22
		[gain1.0
			(map(\i->gain 0.0 (map e0 time)
			[ sinOsc(toNumber i*80.0+440.0)
				(keepLatest $ map (oneOf
						<$> sequence[oon,oof]) time)])
								(0..29))
			]
	myIvl<-memoize
	$ interval ctx 0.25
	$ bang 0.25
	run2 ctx (music myIvl)
  </code></pre>
							</div>
						</div>
					</section>
					<!--

-->

					<section>
						<h3>VDOM-esque-audio: Benchmark</h3>
						<div class="ms-container">
							<div class="ms-col" style="width: 300px">
								<button onclick="toneOff()">Refresh</button>
								<iframe id="toneframe" src="tone.html"></iframe>
							</div>
							<div class="ms-col">
								<pre><code data-trim data-noescape>
const n = 30;
const gainNodes =
Array.from(Array(n).keys())
	.map(()=>newTone.Gain(0.002)
	.toDestination());
const oscs=
	Array.from(Array(n).keys())
	.map((i)=> newTone.Oscillator(440.0+i*80)
	.connect(gainNodes[i]));
	Tone.Transport.scheduleRepeat((time)=>{
		for(var i=0;i&lt;n;i++) {
			oscs[i].start(time).stop(time+0.1);
		}
  },"8n");
Tone.Transport.start();
  </code></pre>
							</div>
						</div>
					</section>
					<section>
						<h3>SDOM's advantages</h3>
						<ul>
							<li>Build a graph declaratively like in Faust or JSX.</li>
							<li>Fast thanks to upfront allocations.</li>
							<li>Each reactive event is very computationally efficient.</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h1>Goal 2</h1>
						<h3>When and how do I use this?</h3>
					</section>
					<section>
						<h3>Case 1: Fixed graphs</h3>
						<iframe
							width="900"
							height="500"
							src="https://docs.wags.fm"
						></iframe>
					</section>
					<section>
						<h3>Case 2: Bounded outcomes</h3>
						<iframe
							width="900"
							height="500"
							src="https://docs.wags.fm"
						></iframe>
					</section>
					<section>
						<h3>SDOM's limitations</h3>
						<ul>
							<li>Dynamism has a more difficult mental model.</li>
							<li>In advanced cases, requires managing subscription logic.</li>
							<li>
								Not very JavaScript-y, functions that emit functions whose
								arguments are functions.
							</li>
						</ul>
					</section>
					<section>
						<h3>Pseudo-code for the aspiring SDOM-er #1</h3>
						<p>Create a bunch of nodes and callbacks.</p>
						<pre><code data-trim data-noescape>
var mySine = new OscillatorNode();
var listeners = [];
var myCb = () => {
	var f = (n) => () => { mySine.frequency = n; }
	listeners.push(f);
	return () => { listeners = listeners.filter(x => x != f); }
}
  </code></pre>
					</section>
					<section>
						<h3>Pseudo-code for the aspiring SDOM-er #2</h3>
						<p>In an event listener, call these callbacks on each event.</p>
						<pre><code data-trim data-noescape>
var mySine = new OscillatorNode();
var listeners = [];
var myCb = () => {
	var f = (n) => () => { mySine.frequency = n; }
	listeners.push(f);
	return () => { listeners = listeners.filter(x => x != f); }
}
//
document.getElementById("myslider")
  .addEventListener('input', n => {
		for (var i = 0; i < listeners; i++) {
			listeners[i](n.value)();
		}
	})
  </code></pre>
					</section>
					<section>
						<h3>Pseudo-code for the aspiring SDOM-er #2</h3>
						<p>
							Thunk the callback to start the audio, and during teardown,
							unsubscribe the nodes.
						</p>
						<pre><code data-trim data-noescape>
var mySine = new OscillatorNode();
var listeners = [];
var myCb = () => { ... }
//
document.getElementById("myslider")
  .addEventListener('input', n => {
		for (var i = 0; i < listeners; i++) {
			listeners[i](n.value)();
		}
	});
//
var unsubscribe = myCb();
// be brilliant
var stopped = unsubscribe();
// no more sound!
  </code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Goal 3</h1>
						<h3>Some theory</h3>
					</section>
					<section>
						<h3>The <code>Event</code> type</h3>
						<pre><code data-trim data-noescape>
type Effect a = Unit -> a -- a thunk
type Event a = (a -> Effect Unit) -> Effect (Effect Unit)
  </code></pre>
						<p>
							If you give me a function that can be thunked whenever a value
							<code>a</code> comes in, I'll give you a thunk-in-a-thunk. The
							first one turns on the stream and the second turns it off.
						</p>
					</section>
					<section>
						<h3><code>Event</code> - a brief history</h3>
						<ul>
							<li>Functional reactive programming: Elliott and Hudak 1997.</li>
							<li>Continuation passing style: Sussman and Steele 1975.</li>
						</ul>
						<pre><code data-trim data-noescape>
type Effect a = Unit -> a -- a thunk
type Event a = (a -> Effect Unit) -> Effect (Effect Unit)
  </code></pre>
					</section>
					<section>
						<h3>Events unlock functional patterns</h3>
						<pre><code data-trim data-noescape>
type Event a = (a -> Effect Unit) -> Effect (Effect Unit)

class Functor m where
  map :: forall a b. (a -> b) -> m a -> m b

instance Functor Event where
  map f (Event ma) = Event (\bEu -> ma (\a -> bEu (f a)))

foo = map (add 42) [1,2,3] -- [43,44,45]
bar = map (add 42) (Just 101) -- (Just 403)
baz = map (add 42) myEvent
  </code></pre>
					</section>
					<section>
						<h3>Brief ode to functional programming 🤓👨‍💻</h3>
						<img src="./images/psfun2.png" />
					</section>
				</section>
				<section>
					<h2>An SDOM Approach to Web Audio</h2>
					<p>Mike Solomon @ joyride.fm</p>
					<a href="https://mikesol-wac2022.surge.sh/"
						>mikesol-wac2022.surge.sh</a
					>
					<p>purescript.org/chat</p>
				</section>
			</div>
		</div>
		<script src="bundle.js"></script>
	</body>
</html>
